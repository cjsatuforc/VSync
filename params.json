{"name":"Vsync","tagline":"An Arduino library to easily synchronize integer values between arduinos (via the Serial interface eg. using XBee)","body":"VSync Library\r\n=============\r\n\r\nThis is the VSync library for the Arduino platform. It can 'magically' synchronize variables on your Arduino with variables on other Arduinos or in your Processing sketch.\r\nLook [here](https://github.com/erniejunior/VSync-for-Processing) for it's Processing counterpart.\r\n\r\nInstallation\r\n------------\r\nTo install the **arduino library** just download the .zip file and look [here](http://arduino.cc/en/Guide/Libraries) for further instructions.\r\nYou can also just clone this git repository into you libraries folder:\r\n```Bash\r\ncd <yoursketchbook>/libraries/\r\ngit clone https://github.com/erniejunior/VSync.git\r\n``` \r\nAfter a restart of the arduino IDE you are done!\r\n\r\nThe **processing version** of the library can be easily installed from within the processing IDE. Just go to `Sketch->Import Library->Add Library' and search for VSync.\r\n\r\nQuick start\r\n-----------\r\n1. Upload the SimpleSender example to your Arduino.\r\n2. Connect something interesting to Analog Pin A0.\r\n3. Open the SimpleReceiver example in Processing.\r\n4. Change the serial port at the head of the setup() to match your Arduino.\r\n5. Hit Run (ctrl+r).\r\n\r\n\r\nUse cases\r\n---------\r\nIf you read the heading off a digital compass and store it in a variable\r\non your Arduino, you can sync that variable with a Processing sketch. In the Processing\r\nsketch you can use it to visualize the digital compass reading ([this example](https://github.com/erniejunior/VSync-for-Processing/blob/master/examples/SimpleReceiver/SimpleReceiver.pde) shows you how to syncronize a variable from an arduio to a processin sketch).\r\n\r\nMaybe you have many settings (color of a RGB LED; angle of a servo motor; parameters\r\nfor a PID algorithm ...), that often need to be changed during the runtime of your Arduino.\r\nSimply synchronize the position of a sliders in your Processing sketch\r\nwith the Arduino to transfer a parameter (like in [this example](https://github.com/erniejunior/VSync-for-Processing/blob/master/examples/CP5_VSync/CP5_VSync.pde), that is using the awesome controlP5 library).\r\n\r\nIt is also possible to sync different variables in two directions at the same time (have a look at [this example](https://github.com/erniejunior/VSync-for-Processing/blob/master/examples/BidirectionalSync/BidirectionalSync.pde)).\r\n\r\n\r\nConcepts\r\n--------\r\nThe idea of this library is to make variables in one sketch (either Arduino or Processing) available in a different sketch. A variable is always synchronized from one side to another side. \r\nLet's assume we have a variable called `servoAngle` on our Arduino [A] and want to use it in our Processing sketch [P]. To synchronize the variable from [A] to [P] we need a ValueSender on the [A] side and a ValueReceiver on the [P] side. \r\n\r\n[A] : ValueSender  -------------~servoAngle~------------->  [P] : ValueReceiver\r\n\r\nNow every time the value of `servoAngle` changes on [A], that change will propagate to [P]. This is a one-way-thing: changing `servoAngle` on the [P] side will not induce any changes at [A]. As soon as [A] sends an update on `servoAngle` the change is overridden.\r\n<sub>(You could use another ValueSender on [P] and a ValueReceiver on [A] to synchronize in the other direction, but VSync is neither built nor tested for that use case. Bad things might happen, if the variable is changed on both sides at the same time!)</sub>\r\n\r\nThese principles apply to all possible synchronization directions:\r\n* Arduino ---> Processing\r\n* Arduino <--- Processing\r\n* Arduino ---> Arduino\r\n* Arduino <--- Arduino\r\n\r\n\r\nUsage\r\n-----\r\nLet's go back to the example in 'Concepts' where we synchronize `servoAngle` from an Arduino to a Processing sketch.\r\n\r\n### On the Arduino side\r\n\r\nFirst you would need to make yourself a new ValueSender object like this:\r\n```C++\r\nValueSender<1> sender;\r\n```\r\nYou are probably confused by the pointy brackets with the 1 in between. That is just a special notation to tell the ValueSender how many variables you want to synchronize.\r\n\r\nAfter you created the ValueSender object you need to tell it what variable you want to synchronize and observe for changes. For this you need to call it's `observe()` function in your `setup()`:\r\n```C++\r\nsender.observe(servoAngle);\r\n```\r\n\r\nFinally you need to make the ValueSender do it's actual synchronization by calling its `sync()` function somewhere in your `loop()`:\r\n```C++\r\nsender.sync();\r\n```\r\n\r\nThe complete sketch would then look like this:\r\n```C++\r\n#include <VSync.h>\r\n\r\nValueSender<1> sender;\r\nint servoAngle;\r\n\r\nvoid setup()\r\n{\r\n  Serial.begin(19200);\r\n  sender.observe(servoAngle);\r\n}\r\n\r\nvoid loop()\r\n{\r\n  ... your code; possibly changing servoAngle ...\r\n\r\n  sender.sync();\r\n}\r\n```\r\n\r\n### On the Processing side\r\n\r\nAfter everything is set up on the Arduino we take care of the receiving end in the Processing sketch.\r\nGet the Processing library [here](https://github.com/erniejunior/VSync-for-Processing).\r\n\r\nBecause Processing is not tightly integrated with serial communication and because there might be more than one Serial interface on your computer we first need to configure a serial object using the serial library:\r\n```Java\r\nSerial serial = new Serial(this, \"<SERIAL_PORT_NAME_HERE>\", 19200);\r\n```\r\nThe easiest way to figure out the right name for the serial port is to have a look in your Arduino IDE and see what port is checked under Tools->Serial Port when you upload code to your Arduino.\r\nOn Linux it often starts with /dev/ttyUSB oder /dev/ttyACM.\r\n\r\nAfter the serial object is set up we can proceed to create the ValueReceiver object like so:\r\n```Java\r\nValueReceiver receiver = new ValueReceiver(this, serial);\r\n```\r\nThis looks a bit different than on the Arduino side because the Processing syntax is slightly different and because we need to somehow pass the serial object to the receiver.\r\n\r\nAfter that everything is quite similar to the Arduino code. We tell the ValueReceiver what variable to observe and synchronize with the `observe()` function `receiver.observe(\"servoAngle\")` (note the quotes around the variable name; another special Processing thing) and we are done because the call to `sync()` is done automagically for you by Processing.\r\n\r\nThe complete Processing sketch would look like this:\r\n```Java\r\nimport processing.serial.*;\r\nimport vsync.*;\r\n\r\npublic int servoAngle;\r\n\r\nvoid setup() \r\n{\r\n  size(400, 400);\r\n\r\n  Serial serial = new Serial(this, \"<SERIAL_PORT_NAME_HERE>\", 19200);\r\n  ValueReceiver receiver = new ValueReceiver(this, serial);\r\n  receiver.observe(\"servoAngle\");\r\n}\r\n\r\nvoid draw() \r\n{\r\n  ... your drawing code, possibly using servoAngle ...\r\n}\r\n\r\n```\r\n\r\nTip for debugging\r\n-----------------\r\n\r\nTo make two Arduinos that are connected to your Linux machine via USB talk to each other just type:\r\n\r\n`dd if=/dev/tty<ALICE> bs=1 of=/dev/tty<BOB> bs=1`\r\n\r\n(Adapt the `<ALICE>` and `<BOB>` part according to the addresses on your computer. Alice is the sending arduino while Bob is the receiving end)\r\n\r\nIf this does not work right away try `screen /dev/tty<ALICE>` and exit it with ctrl+a, k, y. Then try the above line again.\r\n\r\n\r\n\r\nTechnical details\r\n-----------------\r\n\r\n(boring, don't read if you just want to use the library)\r\n    \r\nVSync uses Serial to synchronize int variables, which means that it will work through your USB cable as well as with your XBee. \r\nIt also means it can only do integers and will block any other (e.g. debugging) uses of the Serial interface.\r\n    \r\nThe library uses a very simple human readable protocol that is optimized for minimal data traffic (e.g. only when a variable changes it is sent over the line). The protocol is package based with two kinds of packages:\r\n  * Full-Sync-Package: contains the values of all variables\r\n  * Diff-Sync-Package: contains the values only of variables that changed\r\n  \r\nThe Full-Sync-Package looks like this: A<val1>|<val1>|<val3># if you are syncing three variables. E.g if the variables have the values 4, -8, 555 the package would look like:\r\n```\r\nA|4|-8|555#\r\n```\r\nThe A at the beginning stands for 'all values', the # is the end-character.\r\nThe Diff-Sync-Package looks like this: 0|4|2|555# if value 0 and value 2\r\nchanged to 4 and 555. If only few (1 or 2) variables changed, a Diff-Sync-Package is sent; if lots of variables changed it is more efficient to send a Full-Sync-Package, because the id's of the variables do not need to be sent.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}